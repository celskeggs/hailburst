import os
import subprocess


def build_common(env):
    env["CPPPATH"] += ["include/"]
    return [
        env.Library("main-app", ["fakewire/rmap.c", "main/cmd.c", "main/comm.c", "main/debug.c", "main/heartbeat.c",
                                 "main/magnetometer.c", "main/radio.c", "main/spacecraft.c", "main/tlm.c"]),
        env.Library("fakewire", ["fakewire/codec.c", "fakewire/exchange.c", "main/chart.c", "main/wall.c"])
    ]


# ============================= Linux =============================

def configure_linux():
    linux_env = Environment(CCFLAGS=['-ggdb', '-Wall', '-Wextra', '-Werror', '-D_GNU_SOURCE', '-std=gnu11',
                                     '-Dstatic_assert=_Static_assert'],
                            LIBS=['pthread', 'z'],
                            PREFIX=GetOption('prefix'),
                            CPPPATH=[])

    assert linux_env["CPPPATH"] == [], "cpppath: %r" % linux_env["CPPPATH"]

    for inherit in ["AR", "AS", "LD", "NM", "CC", "CPP", "CXX", "RANLIB", "READELF", "STRIP", "OBJCOPY", "OBJDUMP"]:
        if inherit in os.environ:
            linux_env[inherit] = os.environ[inherit]

    common_libs = build_common(linux_env)

    linux_env["CPPPATH"] += ["linux/include/"]

    LINUX_SRC = ["linux/fakewire_link.c", "linux/platform.c", "linux/queue.c", "linux/semaphore.c", "linux/stream.c"]
    linux_app = linux_env.Program("app", LINUX_SRC + ["linux/clock.c"] + common_libs)
    linux_env.Default(linux_app)

    linux_test = linux_env.Program("fakewire_exc_test", LINUX_SRC +
                                   ["fakewire/test/fakewire_exc_test.c", "fakewire/test/test_common.c"] + common_libs)
    linux_env.Default(linux_test)

    linux_env.Alias("install",
                    [linux_env.Install('$PREFIX/usr/bin', linux_app),
                     linux_env.Install('$PREFIX/etc/init.d', "linux/S80app")])


# ============================= FreeRTOS =============================

def configure_host_plugin(LLVM_BASE):
    host_env = Environment(
        CCFLAGS=[
            "-Wall", "-Wextra", "-Werror",
            "-Wno-unused-parameter",
            "-fno-rtti",
            "-std=gnu++14",
        ],
        CPPPATH=[
            os.path.join(LLVM_BASE, "llvm/include"),
            os.path.join(LLVM_BASE, "clang/include"),
            os.path.join(LLVM_BASE, "build/include"),
            os.path.join(LLVM_BASE, "build/tools/clang/include"),
        ],
    )

    plugin = host_env.SharedLibrary("log-plugin", ["toolchain/log_plugin.cpp"])

    return plugin


def inject_dependency(builder, dependency):
    original = builder.emitter

    def custom_emitter(target, source, env):
        target, source = original(target, source, env)
        env.Depends(target, dependency)
        return target, source
    builder.builder.emitter = custom_emitter


def configure_freertos():
    ROOT_DIR = os.path.abspath("../../..")

    LLVM_BASE = os.path.join(ROOT_DIR, "llvm-project-13")
    CLANG_PATH = os.path.join(LLVM_BASE, "build/bin/clang-13")

    clang_plugin = configure_host_plugin(LLVM_BASE)

    COMMON_FLAGS = [
        "-ggdb",
        "-target", "arm-none-eabi",
        "-mcpu=cortex-a15", "-mfpu=vfpv4", "-mfloat-abi=softfp",
    ]

    rtos_env = Environment(
        CC=CLANG_PATH,
        AS=CLANG_PATH,
        LINK="arm-none-eabi-ld",
        OBJCOPY="arm-none-eabi-objcopy",
        STRIP="arm-none-eabi-strip",
        LINKFLAGS=["-T", "$LINKSCRIPT", "--fatal-warnings"],
        CLANGPLUGIN=clang_plugin,
        CCFLAGS=COMMON_FLAGS + ["-Wall", "-Wextra", "-Werror",
                                # because ealibc uses #pragma mark, and that causes trouble
                                "-Wno-unknown-pragmas",
                                "-nostdlib", "-nostdinc", "-ffreestanding",
                                "-fplugin=$CLANGPLUGIN",
                                "-std=gnu11",
                                "-D_BITSIZE=32", "-D__FREERTOS__"],
        ASFLAGS=COMMON_FLAGS + ["-c", "-Wa,--fatal-warnings"],
        CPPPATH=[],
    )
    inject_dependency(rtos_env['BUILDERS']['Object'], clang_plugin)

    # If we were using a fully working version of clang (i.e. not a clang-13 we baked ourselves), perhaps we could call
    # into the compiler to get a path to a working compiler_rt library (the clang equivalent libgcc).
    # we might do that like the following (which works for GCC)
    if rtos_env['CC'].endswith("gcc"):
        COMPILER_LIBRARY_PATH = subprocess.check_output([rtos_env['CC'], "-print-libgcc-file-name"]).decode().strip()
    # Unfortunately, clang's compiler_rt cannot be easily cross-compiled due to assumptions baked into the cmake
    # scripts, which means we need to build the library ourselves
    else:
        BUILTINS_PATH = os.path.join(LLVM_BASE, "compiler-rt/lib/builtins")
        BUILTINS_ARCH_PATH = os.path.join(BUILTINS_PATH, "arm")
        builtins = {filename.rsplit(".", 1)[0]: os.path.join(BUILTINS_PATH, filename)
                    for filename in os.listdir(BUILTINS_PATH)
                    if filename.endswith(".c")}
        for x in ["emutls", "enable_execute_stack", "eprintf", "gcc_personality_v0"]:
            del builtins[x]
        builtins.update({filename.rsplit(".", 1)[0]: os.path.join(BUILTINS_ARCH_PATH, filename)
                         for filename in os.listdir(BUILTINS_ARCH_PATH)
                         if filename.endswith(".c") or filename.endswith(".S")})
        COMPILER_LIBRARY_PATH = rtos_env.Library("compiler-rt-builtins", sorted(builtins.values()),
                                                 CCFLAGS=rtos_env['CCFLAGS'] + ["-Wno-unused-parameter"])

    # embedded artistry's libc
    EALIBC_ROOT = os.path.join(ROOT_DIR, "ealibc")
    EALIBC_INC = os.path.join(EALIBC_ROOT, "include")

    ZLIB_ROOT = os.path.join(ROOT_DIR, "zlib-1.2.11")

    FREERTOS_ROOT = os.path.join(ROOT_DIR, "FreeRTOS-Kernel")
    FREERTOS_INC = os.path.join(FREERTOS_ROOT, "include")

    common_libs = build_common(rtos_env)
    elf_lib = rtos_env.Library("elf", ["elf/elf.c"])

    rtos_env["CPPPATH"] += [
        "freertos/include/", "bootrom/include/",
        FREERTOS_INC,
        EALIBC_INC, EALIBC_ROOT + "/printf", EALIBC_ROOT + "/arch/arm/include", ZLIB_ROOT
    ]

    ealibc = rtos_env.Library(
        "ealibc",
        [os.path.join(EALIBC_ROOT, "printf/printf.c")] +
        [os.path.join(EALIBC_ROOT, "src", x) for x in
         ["assert/assert.c", "string/memset.c", "string/memcpy.c", "string/memmove.c", "crt/exit.c", "stdlib/rand.c"]]
    )

    RTOS_SRC = ["freertos/clock.c", "freertos/crash.c", "freertos/entrypoint.s", "freertos/fakewire_link.c",
                "freertos/gic.c", "freertos/scrubber.c", "freertos/stubs.c", "freertos/timer.c", "freertos/thread.c",
                "freertos/virtio.c", "freertos/virtio_console.c", "freertos/watchdog.c", "freertos/port.c"]
    EXTERNAL_SRC = [
        COMPILER_LIBRARY_PATH,
        os.path.join(ZLIB_ROOT, "crc32.c"),
        ealibc,
        elf_lib,
    ]
    EXTERNAL_SRC += [os.path.join(FREERTOS_ROOT, x) for x in
                     ["tasks.c", "queue.c", "list.c", "stream_buffer.c", "portable/MemMang/heap_4.c"]]

    rtos_kernel = rtos_env.Program("kernel", RTOS_SRC + common_libs + EXTERNAL_SRC, LINKSCRIPT="freertos/link.ld")
    rtos_env.Depends(rtos_kernel, "freertos/link.ld")
    rtos_env.Default(rtos_kernel)

    stripped_kernel = rtos_env.Command(
        target='stripped-kernel',
        source=rtos_kernel,
        action='$STRIP --strip-all $SOURCE -o $TARGET',
    )

    embedding = rtos_env.Command(
        target='embedded-kernel.o',
        source=stripped_kernel,
        action='$OBJCOPY -I binary -O elf32-littlearm -B arm --strip-all $SOURCE $TARGET',
    )

    BOOTROM_SRC = ["bootrom/boot.c", "bootrom/start.s", ealibc, COMPILER_LIBRARY_PATH, embedding, elf_lib]
    rtos_bootrom_elf = rtos_env.Program("bootrom-elf", BOOTROM_SRC, LINKSCRIPT="bootrom/link.ld")
    rtos_env.Depends(rtos_bootrom_elf, "bootrom/link.ld")

    rtos_bootrom_bin = rtos_env.Command(
        target='bootrom-bin',
        source=rtos_bootrom_elf,
        action='$OBJCOPY -I elf32-littlearm -O binary $SOURCE $TARGET',
    )
    rtos_env.Default(rtos_bootrom_bin)


# ============================= Main =============================

Import("platform")
if platform == "linux":
    configure_linux()
elif platform == "freertos":
    configure_freertos()
else:
    raise RuntimeError("no such platform: %r", platform)
